"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const coc_nvim_1 = require("coc.nvim");
const events_1 = require("events");
const minimatch_1 = __importDefault(require("minimatch"));
const path_1 = __importDefault(require("path"));
const readline_1 = __importDefault(require("readline"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const vscode_uri_1 = __importDefault(require("vscode-uri"));
const util_1 = require("./util");
const ansiparse_1 = require("./util/ansiparse");
const option_1 = require("./util/option");
const lineRegex = /^(.+):(\d+):(\d+):(.*)/;
const controlCode = '\x1b';
class Task extends events_1.EventEmitter {
    constructor(interactive) {
        super();
        this.interactive = interactive;
    }
    start(cmd, args, cwd, patterns) {
        this.process = child_process_1.spawn(cmd, args, { cwd });
        this.process.on('error', e => {
            this.emit('error', e.message);
        });
        this.process.stderr.on('data', chunk => {
            console.error(chunk.toString('utf8')); // tslint:disable-line
        });
        const rl = readline_1.default.createInterface(this.process.stdout);
        let hasPattern = patterns.length > 0;
        rl.on('line', line => {
            let ms;
            let escaped;
            if (line.indexOf(controlCode) !== -1) {
                let parts = ansiparse_1.ansiparse(line);
                escaped = parts.reduce((s, curr) => s + curr.text, '');
                ms = escaped.match(lineRegex);
            }
            else {
                ms = line.match(lineRegex);
                escaped = line;
            }
            if (!ms)
                return;
            let file = path_1.default.join(cwd, ms[1]);
            if (hasPattern && patterns.some(p => minimatch_1.default(file, p)))
                return;
            let pos = vscode_languageserver_protocol_1.Position.create(Number(ms[2]) - 1, byteSlice(ms[4], 0, Number(ms[3]) - 1).length);
            let location = vscode_languageserver_protocol_1.Location.create(vscode_uri_1.default.file(file).toString(), vscode_languageserver_protocol_1.Range.create(pos, pos));
            this.emit('data', {
                label: line,
                filterText: this.interactive ? '' : escaped,
                location
            });
        });
        rl.on('close', () => {
            this.emit('end');
        });
    }
    dispose() {
        if (this.process) {
            this.process.kill();
        }
    }
}
class GrepList extends coc_nvim_1.BasicList {
    constructor(nvim) {
        super(nvim);
        this.interactive = true;
        this.description = 'grep text by rg or ag';
        this.name = 'grep';
        this.defaultAction = 'open';
        this.detail = 'Literal match is used by default.\nTo use interactive mode, add `-I` to LIST OPTIONS.\nTo change colors, checkout `man rg` or `man ag`\nGrep source provide some uniformed options to ease differences between rg and ag.\n';
        this.options = [{
                name: '-S, -smartcase',
                description: 'Use smartcase match.'
            }, {
                name: '-i, -ignorecase',
                description: 'Use ignorecase match.'
            }, {
                name: '-l, -literal',
                description: 'Treat the pattern as a literal string, used when -regex is not used.'
            }, {
                name: '-w, -word',
                description: 'Use word match.'
            }, {
                name: '-e, -regex',
                description: 'Use regex match.'
            }, {
                name: '-u, -skip-vcs-ignores',
                description: 'Don\'t respect version control ignore files(.gitignore, etc.)'
            }, {
                name: '-t, -extension EXTENSION',
                description: 'Grep files with specified extension only, could be used multiple times.'
            }];
        this.addLocationActions();
    }
    async loadItems(context) {
        let { nvim } = this;
        let { interactive } = context.options;
        let config = coc_nvim_1.workspace.getConfiguration('list.source.grep');
        let cmd = config.get('command', 'rg');
        let args = config.get('args', []).slice();
        let useLiteral = config.get('useLiteral', true);
        if (cmd == 'rg') {
            args.push('--color', 'always', '--vimgrep', '--colors', 'path:fg:white');
        }
        else if (cmd == 'ag') {
            args.push('--color', '--vimgrep');
        }
        if (!util_1.executable(cmd))
            throw new Error(`Command '${cmd}' not found on $PATH`);
        if (interactive && !context.input)
            return [];
        args.push(...context.args);
        if (context.input) {
            if (interactive && context.input.indexOf(' ') != -1) {
                let input = context.input.split(/\s+/).join('.*');
                if (!args.includes('-regex') && !args.includes('-e')) {
                    args.push('-regex');
                }
                args.push(input);
            }
            else {
                args.push(context.input);
            }
        }
        let patterns = config.get('excludePatterns', []);
        let { window } = context;
        let valid = await window.valid;
        let cwd;
        if (valid) {
            cwd = await nvim.call('getcwd', window.id);
        }
        else {
            cwd = await nvim.call('getcwd');
        }
        let task = new Task(interactive);
        if (cmd == 'rg' || cmd == 'ag') {
            args = option_1.convertOptions(args, cmd, useLiteral);
        }
        task.start(cmd, args, cwd, patterns);
        return task;
    }
}
exports.default = GrepList;
function byteSlice(content, start, end) {
    let buf = Buffer.from(content, 'utf8');
    return buf.slice(start, end).toString('utf8');
}
//# sourceMappingURL=grep.js.map