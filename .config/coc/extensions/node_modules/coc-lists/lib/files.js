"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const coc_nvim_1 = require("coc.nvim");
const events_1 = require("events");
const find_up_1 = __importDefault(require("find-up"));
const minimatch_1 = __importDefault(require("minimatch"));
const path_1 = __importDefault(require("path"));
const readline_1 = __importDefault(require("readline"));
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const util_1 = require("./util");
class Task extends events_1.EventEmitter {
    constructor() {
        super();
    }
    start(cmd, args, cwd, patterns) {
        this.process = child_process_1.spawn(cmd, args, { cwd });
        this.process.on('error', e => {
            this.emit('error', e.message);
        });
        const rl = readline_1.default.createInterface(this.process.stdout);
        const range = vscode_languageserver_protocol_1.Range.create(0, 0, 0, 0);
        let hasPattern = patterns.length > 0;
        this.process.stderr.on('data', chunk => {
            console.error(chunk.toString('utf8')); // tslint:disable-line
        });
        rl.on('line', line => {
            let file = path_1.default.join(cwd, line);
            if (hasPattern && patterns.some(p => minimatch_1.default(file, p)))
                return;
            let location = vscode_languageserver_protocol_1.Location.create(coc_nvim_1.Uri.file(file).toString(), range);
            this.emit('data', {
                label: line,
                location
            });
        });
        rl.on('close', () => {
            this.emit('end');
        });
    }
    dispose() {
        if (this.process) {
            this.process.kill();
        }
    }
}
class FilesList extends coc_nvim_1.BasicList {
    constructor(nvim) {
        super(nvim);
        this.name = 'files';
        this.defaultAction = 'open';
        this.description = 'search file from cwd';
        this.addLocationActions();
        let config = coc_nvim_1.workspace.getConfiguration('list.source.files');
        this.excludePatterns = config.get('excludePatterns', []);
        coc_nvim_1.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('list.source.files')) {
                let config = coc_nvim_1.workspace.getConfiguration('list.source.files');
                this.excludePatterns = config.get('excludePatterns', []);
            }
        });
    }
    getArgs(args, defaultArgs) {
        return args.length ? args : defaultArgs;
    }
    getCommand(cwd) {
        let config = coc_nvim_1.workspace.getConfiguration('list.source.files');
        let cmd = config.get('command', '');
        let args = config.get('args', []);
        if (!cmd) {
            if (util_1.executable('rg')) {
                return { cmd: 'rg', args: this.getArgs(args, ['--color', 'never', '--files']) };
            }
            else if (util_1.executable('ag')) {
                return { cmd: 'ag', args: this.getArgs(args, ['-f', '-g', '.', '--nocolor']) };
            }
            else if (util_1.executable('git') && find_up_1.default.sync('.git', { cwd })) {
                return { cmd: 'git', args: this.getArgs(args, ['ls-files']) };
            }
            else if (process.platform == 'win32') {
                return { cmd: 'dir', args: this.getArgs(args, ['/a-D', '/S', '/B']) };
            }
            else if (util_1.executable('find')) {
                return { cmd: 'find', args: this.getArgs(args, ['.', '-type', 'f']) };
            }
            else {
                throw new Error('Unable to find command for files list.');
                return null;
            }
        }
        else {
            return { cmd, args };
        }
    }
    async loadItems(context) {
        let { nvim } = this;
        let { window } = context;
        let valid = await window.valid;
        let cwd;
        if (valid) {
            cwd = await nvim.call('getcwd', window.id);
        }
        else {
            cwd = await nvim.call('getcwd');
        }
        let res = this.getCommand(cwd);
        if (!res)
            return null;
        let task = new Task();
        task.start(res.cmd, res.args, cwd, this.excludePatterns);
        return task;
    }
}
exports.default = FilesList;
//# sourceMappingURL=files.js.map